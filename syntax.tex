% -*-latex-*-

\section{Lexical Structure}

Salty specifications are organized as a collection of top-level declarations, all belonging to a single controller specification. The declarations are assumed to be un-ordered, so it's perfectly reasonable to use a variable or macro before its declaration.


\section{Layout}

Salty programs use indentation, rather than delimiters to indicate scoping. For example, when introducing system transition formulas, a, b, and c are all within the scope of the sys\_trans block, while d is not.

\begin{lstlisting}

sys_trans
  a
  b
  c

d

\end{lstlisting}

Anywhere that indentation is significant will be explicitly called out in the remainder of this document. Additionally, in any grammar fragment where layout is assumed to separate terminals, the terminals will be separated by a 'v;' terminal.

\section{Controllers}

The main compilation unit in Salty is the controller. A controller consists of a types, state variables, macro definitions, and environment/system constraint formulae. When synthesis is successful for a controller specification, it takes the form of a function that accepts values for all of the input variables, and produces values for all of the output variables.

\noindent The syntax for controllers is specified by the following grammar fragment:

\begin{lstlisting}
Identifier      = lower-case-letter { IdentifierRest } ;

UpperIdentifier = upper-case-letter { IdentifierRest } ;

IdentifierRest  = letter | '0' - '9' | '_' ;

Controller      = 'controller' UpperIdentifier 'where' TopDecls ;
\end{lstlisting}

\section{Top-level Declarations}

All of the top-level declarations in salty are subject to layout. For example, the following program fragment will cause a parse error:
\begin{lstlisting}
sys_trans a
  input b : Bool
\end{lstlisting}
\noindent as the sys\_trans and input declarations do not start at the same column. As long as they're consistent, the specification should parse; this is a valid fragment:
\begin{lstlisting}
sys_trans a
input b : Bool
\end{lstlisting}
\noindent as is this:
\begin{lstlisting}
  sys_trans a
  input b : Bool
\end{lstlisting}
\noindent The top-level declaration grammar is determined by the following grammar fragments:
\begin{lstlisting}
TopDecls = TopDecl | TopDecl 'v;' TopDecls | <empty> ;

TopDecl = InputDecl | OutputDecl | EnumDecl
        | Constraint | MacroDecl ;
\end{lstlisting}

\section{Types}

The type-language of Salty consists of a few built-in types, and user-defined enumerations. The built-in types are: the function arrow ->, Bool, Int, and Spec. User-defined enumerations will be introduced in the following section.

Bool is the type of boolean-valued expressions, like the constants True and False, as well as inputs and outputs the are introduced with the Bool type.
-> is the type of user-defined macros, and any built-in functions.
Int is the type of numeric expressions.
Spec is the type of constraints, which will be defined in the [Constraints] section.
The types are described by the following grammar:

\begin{lstlisting}
Type = 'Bool' | 'Int' | UpperIdentifier | Type '->' Type
\end{lstlisting}

\section{Enumerations}

Enumerations allow users to introduce a new type and its values. The syntax for introducing an enumeration type is shown below.
\begin{lstlisting}
EnumDecl = 'enum' UpperIdent '=' UpperIdent { '|' UpperIdent }
\end{lstlisting}
For example, if you needed to express a number of different locations as an input to your controller, this would be one way to describe that scenario:
\begin{lstlisting}
enum Locations = Home | Work | InTransit
input current_location : Locations
\end{lstlisting}
With this controller fragment, the user may write constraints about the value of current\_location, with the confidence that it is always one of the values of the Location enumeration (Home, Work, or InTransit).

\section{Expressions}

Expressions can be constants, variables, macro invocations or combinations of those using built-in operators.
\begin{lstlisting}
Exprs = Expr | Expr 'v;' Exprs

Constant = 'True' | 'False' | integer | UpperIdent

Expr = Identifier | Number | Constant | Identifier '(' ExprArgs ')'
     | '{' ExprArgs '}' | 'mutex' Expr | 'all' Expr | 'any' Expr
     | Expr Op Expr | '!' Expr
     | 'if' Expr 'then' Expr 'else' Expr

Op = '||' | '\/' | '\&\&' | '/\\' | '==' | '->' | '<->'

ExprArgs = Expr | Expr ',' Args
\end{lstlisting}

For example, if there is one boolean input, and one boolean output, and you wish to make the value of the output the same as the value of the input, the following controller fragment would achieve that goal:

\begin{lstlisting}
sys_trans inpVar <-> outVar
\end{lstlisting}

\subsection{If-then-else}

The if-then-else syntax that Salty provides is just syntactic sugar for the following expression:
\begin{lstlisting}
if a then b else c == (a -> b) /\ (! a -> c)
\end{lstlisting}
In some cases, this construct can increase the readability of a specification, but there is no special handling associated with it.

\section{Inputs and Outputs}

Input and output declarations define how the controller can interact with the world. Inputs and outputs both follow the same basic structure, but differ in the keyword used to introduce them. The general form is shown below:
\begin{lstlisting}
VarDecl = 'input' | 'output'

InputDecl = VarDecl Identifier ':' Type [ InitValue ]

InitValue = '=' Expr
\end{lstlisting}
Both inputs and outputs have optional initial values, which allows the user to constrain the initial state of the state machine produced. If the initial values are left unspecified for either, the resulting state machine can be a little more complicated.

\section{Constraints}

The behavior of the desired state machine is described by adding safety and liveness constraints on either the environment or system, as top-level declarations. Each of the constraint declaraions can accept one or more expressions, and when more than one are present the declaration is assumed to be the conjunction of all of those expressions. Constraint declarations take the form shown below:
\begin{lstlisting}
Constraint = RawConstraint | Ident '(' ExprArgs ')'

ConstraintOp = 'sys_trans' | 'sys_liveness'
             | 'env_trans' | 'env_liveness' ;
RawConstraint = ConstraintOp Exprs ;
\end{lstlisting}

For example, if you had an input variable named a and an output variable named b that were both Bool-typed, you could enforce this through the following system safety constraint:

\begin{lstlisting}
sys_trans a == b
\end{lstlisting}

In the case where the constraint declaration is a macro invocation (the second case of the Constraint production), the macro must have a result type of Spec, which indicates that it is made up of uses of the raw constraint declarations, or other macros that add constraints.

\section{Macros}

As there can sometimes be quite a lot of repetition in specifications, Salty supports user-defined macros to name common patterns. The basic structure of a macro is given by the following grammar fragment:
\begin{lstlisting}
MacroDecl = 'def' '(' ArgList ')' '=' (Expr | Constraints) ;

ArgList = Identifier | Identifier ',' ArgList | <empty> ;

Constraints = Constraint | Constraint 'v;' Constraints ;
\end{lstlisting}

As you can see from the grammar, the RHS of a macro definition can be either a single expression, or one or more [Constraints]. The reason for this is that macros can be used in two places:

In an expression, where it is being used to compute a single value
At the top-level, where it is used to name a pattern of constraints
The second case is useful for giving a name to a complicated property. For example, if you are designing a command for an autonomous agent, and notice that many commands have a similar structure, you can abstract out the parts that differ, and use one top-level macro invocation instead. For example:

\begin{lstlisting}
def action(enabled, loc, healthy, behavior) =
  sys_trans
    (enabled /\ healthy) ->
      (behavior_out == behavior /\ location_out == loc)

  sys_liveness
    enabled -> behavior_out == behavior

action(command_var == FindTrash, Hallway, BatteryOK == True,
    Search)
action(command_var == DeliverTrash, Garage, BatteryOK == True,
    Transport)
\end{lstlisting}
This way, the intent of the sys\_trans and sys\_liveness properties is encoded in the name of the macro, action. Then, it can be used in place of writing those formulae, but instantiated to their specific purpose.
